# ğŸ“˜ Listas Lineares em C â€” EstÃ¡ticas e DinÃ¢micas

Este documento explica o conceito de **listas lineares** na linguagem C, apresentando a diferenÃ§a entre as **estÃ¡ticas (vetores)** e as **dinÃ¢micas (alocadas com ponteiros)**, com exemplos prÃ¡ticos e explicaÃ§Ãµes.

---

## ğŸ”¹ Lista Linear EstÃ¡tica

Uma **lista estÃ¡tica** Ã© uma estrutura de dados onde os elementos sÃ£o armazenados **em posiÃ§Ãµes contÃ­guas de memÃ³ria** e o **tamanho Ã© fixo** â€” definido no momento da declaraÃ§Ã£o.

- A memÃ³ria Ã© reservada de forma contÃ­nua.
- NÃ£o Ã© possÃ­vel aumentar ou diminuir o tamanho da lista durante a execuÃ§Ã£o.
- O acesso aos elementos Ã© feito diretamente por **Ã­ndice**.

ğŸ“¦ **Exemplo prÃ¡tico:**  
Imagine uma prateleira com divisÃ³rias fixas.  
Cada espaÃ§o sÃ³ comporta um item, e, quando todos os espaÃ§os estÃ£o ocupados, **nÃ£o hÃ¡ como adicionar mais** sem remover outro.

l, l + c, l + 2c ...

cpp
Copiar cÃ³digo
Cada elemento ocupa uma posiÃ§Ã£o de memÃ³ria contÃ­gua.

### ğŸ§  Exemplo em C

```c
#include <stdio.h>

int main() {
    int numeros[5] = {10, 20, 30, 40, 50};

    printf("%d", numeros[2]);  // Imprime 30
    return 0;
}
ğŸ“ Resumo:

Lista com 5 posiÃ§Ãµes fixas.

NÃ£o Ã© possÃ­vel alterar o tamanho apÃ³s a criaÃ§Ã£o.

ğŸ”¹ Lista Linear DinÃ¢mica
A lista dinÃ¢mica Ã© uma estrutura que tambÃ©m armazena elementos em sequÃªncia,
mas pode crescer ou diminuir durante a execuÃ§Ã£o do programa conforme necessÃ¡rio.

Usa ponteiros e funÃ§Ãµes de alocaÃ§Ã£o dinÃ¢mica de memÃ³ria:

malloc â†’ aloca espaÃ§o inicial.

realloc â†’ redimensiona mantendo os dados antigos.

free â†’ libera a memÃ³ria quando nÃ£o for mais usada.

ğŸ“¦ Exemplo prÃ¡tico:
Imagine uma caixa dobrÃ¡vel que pode expandir ou diminuir o tamanho conforme vocÃª adiciona ou remove itens.

ğŸ§  Exemplo em C
c
Copiar cÃ³digo
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 1. Criar a lista com 3 posiÃ§Ãµes
    int* numeros = (int*) malloc(3 * sizeof(int));

    // 2. Atribuir os valores iniciais
    numeros[0] = 10;
    numeros[1] = 20;
    numeros[2] = 30;

    // 3. Expandir a lista para 5 posiÃ§Ãµes
    numeros = (int*) realloc(numeros, 5 * sizeof(int));

    // 4. Atribuir novos valores
    numeros[3] = 40;
    numeros[4] = 50;

    // Exibir os valores da lista
    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }

    // Liberar memÃ³ria
    free(numeros);
    return 0;
}
ğŸ“ Resumo:

Pode crescer e diminuir conforme a necessidade.

A alocaÃ§Ã£o de memÃ³ria Ã© feita em tempo de execuÃ§Ã£o.

Exige o uso de ponteiros e funÃ§Ãµes especÃ­ficas de gerenciamento de memÃ³ria.

âš™ï¸ FunÃ§Ãµes Importantes
FunÃ§Ã£o	DescriÃ§Ã£o
malloc()	Aloca dinamicamente um bloco de memÃ³ria.
realloc()	Redimensiona um bloco jÃ¡ alocado.
free()	Libera a memÃ³ria previamente alocada.

ğŸ“˜ ConclusÃ£o
Tipo	CaracterÃ­sticas	Vantagens	LimitaÃ§Ãµes
EstÃ¡tica	Tamanho fixo e posiÃ§Ãµes contÃ­guas	Acesso rÃ¡pido por Ã­ndice	NÃ£o redimensionÃ¡vel
DinÃ¢mica	Usa ponteiros e cresce conforme necessÃ¡rio	FlexÃ­vel e eficiente no uso de memÃ³ria	Mais complexa de implementar

ğŸ“š Listas Encadeadas em C

As listas encadeadas sÃ£o estruturas de dados dinÃ¢micas compostas por nÃ³s (structs), onde cada nÃ³ armazena um valor (dado) e um ponteiro que indica o prÃ³ximo elemento da lista.
Elas permitem inserir e remover elementos de forma flexÃ­vel, diferente dos vetores, que tÃªm tamanho fixo.

ğŸ¥š Analogia simples

Pense em uma caÃ§a aos ovos de PÃ¡scoa ğŸ£:
Cada ovo estÃ¡ em um lugar diferente (cozinha, quarto, sala...), mas vocÃª precisa de uma pista (ponteiro) que te leve de um ovo ao prÃ³ximo.
Assim funciona uma lista encadeada â€” cada elemento sabe onde estÃ¡ o prÃ³ximo.

ğŸ§© Estrutura bÃ¡sica de um nÃ³
struct No {
    int dado;              // Onde guardamos a informaÃ§Ã£o
    struct No* proximo;    // A seta que aponta para o prÃ³ximo nÃ³
};

â• Inserindo em uma posiÃ§Ã£o especÃ­fica

Para inserir um novo elemento em uma posiÃ§Ã£o especÃ­fica da lista, vocÃª precisa:

Criar um novo nÃ³.

Percorrer a lista atÃ© a posiÃ§Ã£o desejada.

Ajustar os ponteiros para â€œencaixarâ€ o novo nÃ³ na posiÃ§Ã£o certa.

ğŸ”— Tipos de listas encadeadas
1. Lista Encadeada Simples

Cada nÃ³ aponta apenas para o prÃ³ximo elemento da lista.

struct No {
    int dado;
    struct No* proximo;
};

2. Lista Duplamente Encadeada

Cada nÃ³ aponta tanto para o prÃ³ximo quanto para o anterior, permitindo percorrer a lista nos dois sentidos.

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

3. Lista Circular Simples

O Ãºltimo nÃ³ aponta de volta para o primeiro, formando um ciclo.

struct No {
    int dado;
    struct No* proximo; // o Ãºltimo aponta para o primeiro
};

4. Lista Circular Duplamente Encadeada

Cada nÃ³ aponta para o prÃ³ximo e o anterior, e o Ãºltimo nÃ³ aponta para o primeiro (e vice-versa).

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

ğŸ’¡ ObservaÃ§Ãµes

As listas encadeadas sÃ£o Ãºteis quando hÃ¡ muitas inserÃ§Ãµes e remoÃ§Ãµes dinÃ¢micas.

Elas consomem mais memÃ³ria que um vetor, pois armazenam ponteiros.

SÃ£o amplamente usadas em pilhas, filas e implementaÃ§Ãµes de Ã¡rvores.

# ğŸ§  OperaÃ§Ãµes em Listas Encadeadas (C)

Este material apresenta as principais operaÃ§Ãµes realizadas em uma **lista encadeada simples** em linguagem C: **inserÃ§Ã£o**, **remoÃ§Ã£o** e **percorrimento**.

---

## ğŸ“¦ Estrutura do NÃ³

Cada nÃ³ da lista contÃ©m um valor (`dado`) e um ponteiro (`proximo`) que aponta para o prÃ³ximo elemento.

```c
struct No {
    int dado;
    struct No* proximo;
};
```

---

## â• InserÃ§Ã£o no InÃ­cio da Lista

A funÃ§Ã£o abaixo insere um novo elemento **no inÃ­cio** da lista encadeada.

```c
void inserirNoInicio(struct No** inicio, int valor) {
    struct No* novo = (struct No*) malloc(sizeof(struct No));
    novo->dado = valor;
    novo->proximo = *inicio;
    *inicio = novo;
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
1. Aloca memÃ³ria para o novo nÃ³.  
2. Define o valor (`dado`) e faz o novo nÃ³ apontar para o antigo inÃ­cio.  
3. Atualiza o ponteiro de inÃ­cio para o novo nÃ³.  

---

## âŒ RemoÃ§Ã£o do InÃ­cio da Lista

A funÃ§Ã£o remove o **primeiro elemento** da lista, liberando a memÃ³ria alocada.

```c
void removerDoInicio(struct No** inicio) {
    if (*inicio != NULL) {
        struct No* temp = *inicio;
        *inicio = (*inicio)->proximo;
        free(temp);
    }
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
1. Verifica se a lista nÃ£o estÃ¡ vazia.  
2. Armazena o ponteiro do primeiro nÃ³ em `temp`.  
3. Move o ponteiro `inicio` para o prÃ³ximo nÃ³.  
4. Libera a memÃ³ria do nÃ³ removido.  

---

## ğŸ” Percorrer e Listar os Elementos

A funÃ§Ã£o percorre toda a lista, exibindo os valores armazenados em cada nÃ³.

```c
void listar(struct No* inicio) {
    struct No* atual = inicio;
    while (atual != NULL) {
        printf("%d\n", atual->dado);
        atual = atual->proximo;
    }
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
Percorre a lista do inÃ­cio atÃ© o final, imprimindo cada elemento atÃ© encontrar `NULL`.

---

## ğŸ§© Exemplo de Uso

```c
#include <stdio.h>
#include <stdlib.h>

struct No {
    int dado;
    struct No* proximo;
};

void inserirNoInicio(struct No** inicio, int valor);
void removerDoInicio(struct No** inicio);
void listar(struct No* inicio);

int main() {
    struct No* inicio = NULL;

    inserirNoInicio(&inicio, 10);
    inserirNoInicio(&inicio, 20);
    inserirNoInicio(&inicio, 30);

    printf("Lista atual:\n");
    listar(inicio);

    removerDoInicio(&inicio);
    printf("\nApÃ³s remover o primeiro elemento:\n");
    listar(inicio);

    return 0;
}
```

---

## ğŸ§¾ Resultado Esperado

```
Lista atual:
30
20
10

ApÃ³s remover o primeiro elemento:
20
10
```

---

## ğŸ§° Conceitos Envolvidos

- Ponteiros e alocaÃ§Ã£o dinÃ¢mica (`malloc` e `free`)  
- Estruturas (`struct`)  
- Passagem por referÃªncia (`**inicio`)  
- ManipulaÃ§Ã£o de listas encadeadas  

---

ğŸ“˜ **Autor:** Matheus Leite  
ğŸ’¡ **Tema:** Estruturas de Dados â€“ Listas Encadeadas  

# Busca Linear em C

A **busca linear** Ã© um algoritmo utilizado para procurar um item em uma lista ou vetor, verificando cada elemento sequencialmente atÃ© encontrar o valor desejado.

---

## Exemplos PrÃ¡ticos

### 1. Busca Linear em Vetor

```c
int buscaLinear(int lista[], int tamanho, int valor) {
    for (int i = 0; i < tamanho; i++) {
        if (lista[i] == valor) {
            return i; // Retorna o Ã­ndice onde encontrou o valor
        }
    }
    return -1; // Retorna -1 se nÃ£o encontrou
}
```

### 2. Busca Linear em Lista Encadeada

```c
struct No {
    int dado;
    struct No* proximo;
};

int buscaLinearLista(struct No* inicio, int valor) {
    int pos = 0;
    struct No* atual = inicio;
    while (atual != NULL) {
        if (atual->dado == valor) {
            return pos; // Retorna a posiÃ§Ã£o onde encontrou
        }
        atual = atual->proximo;
        pos++;
    }
    return -1; // Retorna -1 se nÃ£o encontrou
}
```

---

## Vantagens e Desvantagens

**Vantagem:**

* Simples de implementar e entender.

**Desvantagem:**

* NÃ£o Ã© eficiente para listas grandes, pois precisa percorrer todos os elementos no pior caso.

## ğŸ§© ManipulaÃ§Ã£o por Encadeamento x Estruturas Sequenciais

### ğŸ”¹ ManipulaÃ§Ã£o Sequencial
Ideal para **acesso rÃ¡pido** e **listas de tamanho conhecido**  
ğŸ’¡ *Exemplo:* vetor de temperaturas de uma semana.

### ğŸ”¹ ManipulaÃ§Ã£o por Encadeamento
Recomendada para casos em que o **tamanho da lista varia** ou hÃ¡ **muitas inserÃ§Ãµes/remoÃ§Ãµes no meio**  
ğŸ’¡ *Exemplo:* sistema de filas dinÃ¢micas, listas de tarefas e buffers.

---

### âš™ï¸ Comparativo entre Estruturas

| **OperaÃ§Ã£o**              | **Estrutura Sequencial (Vetor)**           | **Estrutura Encadeada (Lista)**         |
|----------------------------|-------------------------------------------|----------------------------------------|
| **Acesso por posiÃ§Ã£o**     | RÃ¡pido                                   | Lento                                  |
| **InserÃ§Ã£o no meio**       | Lenta â€“ desloca dados                    | RÃ¡pida â€“ ajusta ponteiros              |
| **RemoÃ§Ã£o no meio**        | Lenta â€“ desloca dados                    | RÃ¡pida â€“ ajusta ponteiros              |
| **Crescimento da estrutura** | Limitado ao tamanho fixo                 | FlexÃ­vel â€“ cresce conforme uso         |
| **Uso de memÃ³ria**         | ContÃ­guo e previsÃ­vel                    | Fragmentado e dinÃ¢mico                 |

---

ğŸ’­ **Resumo:**
- Vetores sÃ£o Ã³timos para **acessos diretos e listas fixas**.  
- Listas encadeadas sÃ£o ideais para **manipulaÃ§Ã£o dinÃ¢mica de dados** (crescem e reduzem facilmente).

## ğŸ” Busca BinÃ¡ria (Binary Search)

A **busca binÃ¡ria** Ã© um algoritmo utilizado para encontrar um elemento **em um vetor ordenado**.  
Diferente da busca linear, que percorre todos os elementos, a busca binÃ¡ria **divide o vetor ao meio** a cada comparaÃ§Ã£o, tornando o processo muito mais eficiente.

---

### âš™ï¸ Requisitos
- O vetor **deve estar ordenado** (crescente ou decrescente).
- O algoritmo trabalha com trÃªs variÃ¡veis principais:
  - `inicio` â†’ primeira posiÃ§Ã£o do vetor  
  - `fim` â†’ Ãºltima posiÃ§Ã£o do vetor  
  - `meio` â†’ posiÃ§Ã£o central usada na comparaÃ§Ã£o

---

### ğŸ§  LÃ³gica Passo a Passo
1. **Calcula o meio** do vetor:  
   `meio = (inicio + fim) / 2`
2. **Compara o valor procurado** com o elemento da posiÃ§Ã£o `meio`:
   - Se for **igual**, encontrou o valor.
   - Se o valor procurado for **maior**, ignora a metade esquerda e move `inicio = meio + 1`.
   - Se o valor procurado for **menor**, ignora a metade direita e move `fim = meio - 1`.
3. O processo se repete atÃ©:
   - Encontrar o valor â†’ retorna o Ã­ndice.
   - Ou `inicio > fim` â†’ significa que o valor **nÃ£o estÃ¡ na lista**.

---

### ğŸ’» Exemplo em C

```c
int buscaBinaria(int vetor[], int tamanho, int valor) {
    int inicio = 0, fim = tamanho - 1;

    while (inicio <= fim) {
        int meio = (inicio + fim) / 2;

        if (vetor[meio] == valor)
            return meio;  // Valor encontrado
        else if (vetor[meio] < valor)
            inicio = meio + 1;  // Busca na metade direita
        else
            fim = meio - 1;     // Busca na metade esquerda
    }

    return -1; // Valor nÃ£o encontrado
}
ğŸ§© Exemplo prÃ¡tico

Vetor: [10, 20, 30, 40, 50]
Valor procurado: 30

Passo	inÃ­cio	fim	meio	vetor[meio]	ComparaÃ§Ã£o	AÃ§Ã£o
1	0	4	2	30	igual	Encontrou

âœ… Resultado: Ã­ndice 2 (terceira posiÃ§Ã£o do vetor).

ğŸ§® Vantagens

Muito mais rÃ¡pida que a busca linear em listas grandes.

O nÃºmero de comparaÃ§Ãµes Ã© proporcional a logâ‚‚(n).

âš ï¸ AtenÃ§Ã£o

Somente funciona se o vetor estiver ordenado.

NÃ£o Ã© indicada para listas encadeadas, pois exige acesso direto por Ã­ndice.

ğŸ’¡ Resumo:
A busca binÃ¡ria Ã© uma tÃ©cnica de â€œdividir e conquistarâ€.
Ela corta o problema ao meio a cada passo, reduzindo o tempo de busca de forma exponencial.


# ImplementaÃ§Ã£o Recursiva e Iterativa

## ğŸŒ€ ImplementaÃ§Ã£o Iterativa
A implementaÃ§Ã£o **iterativa** usa **laÃ§os de repetiÃ§Ã£o** (`for`, `while`) para executar instruÃ§Ãµes atÃ© que uma condiÃ§Ã£o de parada seja atingida.

### âœ… Vantagens
- Mais eficiente em termos de **uso de memÃ³ria** (evita empilhamento de chamadas).  
- Costuma ser **mais rÃ¡pida na execuÃ§Ã£o em baixo nÃ­vel**.  
- EstÃ¡ mais prÃ³xima da forma como o **computador executa instruÃ§Ãµes**.

---

## ğŸ” ImplementaÃ§Ã£o Recursiva
A implementaÃ§Ã£o **recursiva** resolve o problema **dividindo-o em subproblemas menores**, chamando a **prÃ³pria funÃ§Ã£o** com novos parÃ¢metros.  
A cada chamada, uma nova instÃ¢ncia da funÃ§Ã£o Ã© empilhada atÃ© que a **condiÃ§Ã£o de parada** seja alcanÃ§ada.

### âœ… Vantagens
- CÃ³digo mais **limpo e elegante**.  
- Ideal para problemas **naturalmente recursivos** (como Ã¡rvores, grafos ou cÃ¡lculo de fatorial).

### âš ï¸ Desvantagens
- Pode **consumir mais memÃ³ria**, pois cada chamada ocupa espaÃ§o na pilha.  
- Pode causar **â€œestouro de pilhaâ€** se nÃ£o houver condiÃ§Ã£o de parada ou se o nÃºmero de chamadas for muito grande.

# ğŸ” Busca Sequencial x Busca BinÃ¡ria

## âš™ï¸ Busca Sequencial
A **busca sequencial** percorre a lista **um a um**, verificando cada elemento atÃ© encontrar o valor desejado.

### ğŸ§© Exemplo prÃ¡tico em C
```c
int buscaSequencial(int vetor[], int tamanho, int valor) {
    for (int i = 0; i < tamanho; i++) {
        if (vetor[i] == valor) {
            return i;
        }
    }
    return -1; // valor nÃ£o encontrado
}
âœ… CaracterÃ­sticas
NÃ£o exige que os dados estejam ordenados.

Simples de implementar e entender.

Funciona em qualquer estrutura linear (vetores ou listas).

âš™ï¸ Busca BinÃ¡ria
A busca binÃ¡ria Ã© um mÃ©todo mais eficiente, que divide o vetor ao meio a cada passo, eliminando metade dos elementos que nÃ£o podem conter o valor procurado.

âš ï¸ Importante: Os dados precisam estar ordenados para que a busca binÃ¡ria funcione corretamente.

ğŸ§© Exemplo prÃ¡tico em C
c
Copiar cÃ³digo
int buscaBinaria(int vetor[], int tamanho, int valor) {
    int inicio = 0, fim = tamanho - 1;

    while (inicio <= fim) {
        int meio = (inicio + fim) / 2;

        if (vetor[meio] == valor)
            return meio;
        else if (vetor[meio] < valor)
            inicio = meio + 1;
        else
            fim = meio - 1;
    }
    return -1; // valor nÃ£o encontrado
}
âš–ï¸ Comparativo entre Busca Sequencial e Busca BinÃ¡ria
CritÃ©rio	Busca Sequencial	Busca BinÃ¡ria
Dados precisam estar ordenados?	âŒ NÃ£o	âœ… Sim
Facilidade de implementaÃ§Ã£o	Muito fÃ¡cil	Um pouco mais complexa
Desempenho em listas pequenas	Suficiente	Muito bom
Desempenho em listas grandes	Lento	RÃ¡pido
AplicÃ¡vel a listas encadeadas	âœ… Sim	âš ï¸ NÃ£o Ã© ideal

ğŸ’¡ ConclusÃ£o
Use busca sequencial quando os dados nÃ£o estÃ£o ordenados ou o conjunto Ã© pequeno.

Use busca binÃ¡ria quando os dados estÃ£o ordenados e o conjunto Ã© grande, pois ela Ã© muito mais eficiente.


