# üìò Listas Lineares em C ‚Äî Est√°ticas e Din√¢micas

Este documento explica o conceito de **listas lineares** na linguagem C, apresentando a diferen√ßa entre as **est√°ticas (vetores)** e as **din√¢micas (alocadas com ponteiros)**, com exemplos pr√°ticos e explica√ß√µes.

---

## üîπ Lista Linear Est√°tica

Uma **lista est√°tica** √© uma estrutura de dados onde os elementos s√£o armazenados **em posi√ß√µes cont√≠guas de mem√≥ria** e o **tamanho √© fixo** ‚Äî definido no momento da declara√ß√£o.

- A mem√≥ria √© reservada de forma cont√≠nua.
- N√£o √© poss√≠vel aumentar ou diminuir o tamanho da lista durante a execu√ß√£o.
- O acesso aos elementos √© feito diretamente por **√≠ndice**.

üì¶ **Exemplo pr√°tico:**  
Imagine uma prateleira com divis√≥rias fixas.  
Cada espa√ßo s√≥ comporta um item, e, quando todos os espa√ßos est√£o ocupados, **n√£o h√° como adicionar mais** sem remover outro.

l, l + c, l + 2c ...

cpp
Copiar c√≥digo
Cada elemento ocupa uma posi√ß√£o de mem√≥ria cont√≠gua.

### üß† Exemplo em C

```c
#include <stdio.h>

int main() {
    int numeros[5] = {10, 20, 30, 40, 50};

    printf("%d", numeros[2]);  // Imprime 30
    return 0;
}
üìç Resumo:

Lista com 5 posi√ß√µes fixas.

N√£o √© poss√≠vel alterar o tamanho ap√≥s a cria√ß√£o.

üîπ Lista Linear Din√¢mica
A lista din√¢mica √© uma estrutura que tamb√©m armazena elementos em sequ√™ncia,
mas pode crescer ou diminuir durante a execu√ß√£o do programa conforme necess√°rio.

Usa ponteiros e fun√ß√µes de aloca√ß√£o din√¢mica de mem√≥ria:

malloc ‚Üí aloca espa√ßo inicial.

realloc ‚Üí redimensiona mantendo os dados antigos.

free ‚Üí libera a mem√≥ria quando n√£o for mais usada.

üì¶ Exemplo pr√°tico:
Imagine uma caixa dobr√°vel que pode expandir ou diminuir o tamanho conforme voc√™ adiciona ou remove itens.

üß† Exemplo em C
c
Copiar c√≥digo
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 1. Criar a lista com 3 posi√ß√µes
    int* numeros = (int*) malloc(3 * sizeof(int));

    // 2. Atribuir os valores iniciais
    numeros[0] = 10;
    numeros[1] = 20;
    numeros[2] = 30;

    // 3. Expandir a lista para 5 posi√ß√µes
    numeros = (int*) realloc(numeros, 5 * sizeof(int));

    // 4. Atribuir novos valores
    numeros[3] = 40;
    numeros[4] = 50;

    // Exibir os valores da lista
    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }

    // Liberar mem√≥ria
    free(numeros);
    return 0;
}
üìç Resumo:

Pode crescer e diminuir conforme a necessidade.

A aloca√ß√£o de mem√≥ria √© feita em tempo de execu√ß√£o.

Exige o uso de ponteiros e fun√ß√µes espec√≠ficas de gerenciamento de mem√≥ria.

‚öôÔ∏è Fun√ß√µes Importantes
Fun√ß√£o	Descri√ß√£o
malloc()	Aloca dinamicamente um bloco de mem√≥ria.
realloc()	Redimensiona um bloco j√° alocado.
free()	Libera a mem√≥ria previamente alocada.

üìò Conclus√£o
Tipo	Caracter√≠sticas	Vantagens	Limita√ß√µes
Est√°tica	Tamanho fixo e posi√ß√µes cont√≠guas	Acesso r√°pido por √≠ndice	N√£o redimension√°vel
Din√¢mica	Usa ponteiros e cresce conforme necess√°rio	Flex√≠vel e eficiente no uso de mem√≥ria	Mais complexa de implementar

üìö Listas Encadeadas em C

As listas encadeadas s√£o estruturas de dados din√¢micas compostas por n√≥s (structs), onde cada n√≥ armazena um valor (dado) e um ponteiro que indica o pr√≥ximo elemento da lista.
Elas permitem inserir e remover elementos de forma flex√≠vel, diferente dos vetores, que t√™m tamanho fixo.

ü•ö Analogia simples

Pense em uma ca√ßa aos ovos de P√°scoa üê£:
Cada ovo est√° em um lugar diferente (cozinha, quarto, sala...), mas voc√™ precisa de uma pista (ponteiro) que te leve de um ovo ao pr√≥ximo.
Assim funciona uma lista encadeada ‚Äî cada elemento sabe onde est√° o pr√≥ximo.

üß© Estrutura b√°sica de um n√≥
struct No {
    int dado;              // Onde guardamos a informa√ß√£o
    struct No* proximo;    // A seta que aponta para o pr√≥ximo n√≥
};

‚ûï Inserindo em uma posi√ß√£o espec√≠fica

Para inserir um novo elemento em uma posi√ß√£o espec√≠fica da lista, voc√™ precisa:

Criar um novo n√≥.

Percorrer a lista at√© a posi√ß√£o desejada.

Ajustar os ponteiros para ‚Äúencaixar‚Äù o novo n√≥ na posi√ß√£o certa.

üîó Tipos de listas encadeadas
1. Lista Encadeada Simples

Cada n√≥ aponta apenas para o pr√≥ximo elemento da lista.

struct No {
    int dado;
    struct No* proximo;
};

2. Lista Duplamente Encadeada

Cada n√≥ aponta tanto para o pr√≥ximo quanto para o anterior, permitindo percorrer a lista nos dois sentidos.

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

3. Lista Circular Simples

O √∫ltimo n√≥ aponta de volta para o primeiro, formando um ciclo.

struct No {
    int dado;
    struct No* proximo; // o √∫ltimo aponta para o primeiro
};

4. Lista Circular Duplamente Encadeada

Cada n√≥ aponta para o pr√≥ximo e o anterior, e o √∫ltimo n√≥ aponta para o primeiro (e vice-versa).

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

üí° Observa√ß√µes

As listas encadeadas s√£o √∫teis quando h√° muitas inser√ß√µes e remo√ß√µes din√¢micas.

Elas consomem mais mem√≥ria que um vetor, pois armazenam ponteiros.

S√£o amplamente usadas em pilhas, filas e implementa√ß√µes de √°rvores.

# üß† Opera√ß√µes em Listas Encadeadas (C)

Este material apresenta as principais opera√ß√µes realizadas em uma **lista encadeada simples** em linguagem C: **inser√ß√£o**, **remo√ß√£o** e **percorrimento**.

---

## üì¶ Estrutura do N√≥

Cada n√≥ da lista cont√©m um valor (`dado`) e um ponteiro (`proximo`) que aponta para o pr√≥ximo elemento.

```c
struct No {
    int dado;
    struct No* proximo;
};
```

---

## ‚ûï Inser√ß√£o no In√≠cio da Lista

A fun√ß√£o abaixo insere um novo elemento **no in√≠cio** da lista encadeada.

```c
void inserirNoInicio(struct No** inicio, int valor) {
    struct No* novo = (struct No*) malloc(sizeof(struct No));
    novo->dado = valor;
    novo->proximo = *inicio;
    *inicio = novo;
}
```

üß© **Explica√ß√£o resumida:**  
1. Aloca mem√≥ria para o novo n√≥.  
2. Define o valor (`dado`) e faz o novo n√≥ apontar para o antigo in√≠cio.  
3. Atualiza o ponteiro de in√≠cio para o novo n√≥.  

---

## ‚ùå Remo√ß√£o do In√≠cio da Lista

A fun√ß√£o remove o **primeiro elemento** da lista, liberando a mem√≥ria alocada.

```c
void removerDoInicio(struct No** inicio) {
    if (*inicio != NULL) {
        struct No* temp = *inicio;
        *inicio = (*inicio)->proximo;
        free(temp);
    }
}
```

üß© **Explica√ß√£o resumida:**  
1. Verifica se a lista n√£o est√° vazia.  
2. Armazena o ponteiro do primeiro n√≥ em `temp`.  
3. Move o ponteiro `inicio` para o pr√≥ximo n√≥.  
4. Libera a mem√≥ria do n√≥ removido.  

---

## üîÅ Percorrer e Listar os Elementos

A fun√ß√£o percorre toda a lista, exibindo os valores armazenados em cada n√≥.

```c
void listar(struct No* inicio) {
    struct No* atual = inicio;
    while (atual != NULL) {
        printf("%d\n", atual->dado);
        atual = atual->proximo;
    }
}
```

üß© **Explica√ß√£o resumida:**  
Percorre a lista do in√≠cio at√© o final, imprimindo cada elemento at√© encontrar `NULL`.

---

## üß© Exemplo de Uso

```c
#include <stdio.h>
#include <stdlib.h>

struct No {
    int dado;
    struct No* proximo;
};

void inserirNoInicio(struct No** inicio, int valor);
void removerDoInicio(struct No** inicio);
void listar(struct No* inicio);

int main() {
    struct No* inicio = NULL;

    inserirNoInicio(&inicio, 10);
    inserirNoInicio(&inicio, 20);
    inserirNoInicio(&inicio, 30);

    printf("Lista atual:\n");
    listar(inicio);

    removerDoInicio(&inicio);
    printf("\nAp√≥s remover o primeiro elemento:\n");
    listar(inicio);

    return 0;
}
```

---

## üßæ Resultado Esperado

```
Lista atual:
30
20
10

Ap√≥s remover o primeiro elemento:
20
10
```

---

## üß∞ Conceitos Envolvidos

- Ponteiros e aloca√ß√£o din√¢mica (`malloc` e `free`)  
- Estruturas (`struct`)  
- Passagem por refer√™ncia (`**inicio`)  
- Manipula√ß√£o de listas encadeadas  

---

üìò **Autor:** Matheus Leite  
üí° **Tema:** Estruturas de Dados ‚Äì Listas Encadeadas  

# Busca Linear em C

A **busca linear** √© um algoritmo utilizado para procurar um item em uma lista ou vetor, verificando cada elemento sequencialmente at√© encontrar o valor desejado.

---

## Exemplos Pr√°ticos

### 1. Busca Linear em Vetor

```c
int buscaLinear(int lista[], int tamanho, int valor) {
    for (int i = 0; i < tamanho; i++) {
        if (lista[i] == valor) {
            return i; // Retorna o √≠ndice onde encontrou o valor
        }
    }
    return -1; // Retorna -1 se n√£o encontrou
}
```

### 2. Busca Linear em Lista Encadeada

```c
struct No {
    int dado;
    struct No* proximo;
};

int buscaLinearLista(struct No* inicio, int valor) {
    int pos = 0;
    struct No* atual = inicio;
    while (atual != NULL) {
        if (atual->dado == valor) {
            return pos; // Retorna a posi√ß√£o onde encontrou
        }
        atual = atual->proximo;
        pos++;
    }
    return -1; // Retorna -1 se n√£o encontrou
}
```

---

## Vantagens e Desvantagens

**Vantagem:**

* Simples de implementar e entender.

**Desvantagem:**

* N√£o √© eficiente para listas grandes, pois precisa percorrer todos os elementos no pior caso.


