# ğŸ“˜ Listas Lineares em C â€” EstÃ¡ticas e DinÃ¢micas

Este documento explica o conceito de **listas lineares** na linguagem C, apresentando a diferenÃ§a entre as **estÃ¡ticas (vetores)** e as **dinÃ¢micas (alocadas com ponteiros)**, com exemplos prÃ¡ticos e explicaÃ§Ãµes.

---

## ğŸ”¹ Lista Linear EstÃ¡tica

Uma **lista estÃ¡tica** Ã© uma estrutura de dados onde os elementos sÃ£o armazenados **em posiÃ§Ãµes contÃ­guas de memÃ³ria** e o **tamanho Ã© fixo** â€” definido no momento da declaraÃ§Ã£o.

- A memÃ³ria Ã© reservada de forma contÃ­nua.
- NÃ£o Ã© possÃ­vel aumentar ou diminuir o tamanho da lista durante a execuÃ§Ã£o.
- O acesso aos elementos Ã© feito diretamente por **Ã­ndice**.

ğŸ“¦ **Exemplo prÃ¡tico:**  
Imagine uma prateleira com divisÃ³rias fixas.  
Cada espaÃ§o sÃ³ comporta um item, e, quando todos os espaÃ§os estÃ£o ocupados, **nÃ£o hÃ¡ como adicionar mais** sem remover outro.

l, l + c, l + 2c ...

cpp
Copiar cÃ³digo
Cada elemento ocupa uma posiÃ§Ã£o de memÃ³ria contÃ­gua.

### ğŸ§  Exemplo em C

```c
#include <stdio.h>

int main() {
    int numeros[5] = {10, 20, 30, 40, 50};

    printf("%d", numeros[2]);  // Imprime 30
    return 0;
}
ğŸ“ Resumo:

Lista com 5 posiÃ§Ãµes fixas.

NÃ£o Ã© possÃ­vel alterar o tamanho apÃ³s a criaÃ§Ã£o.

ğŸ”¹ Lista Linear DinÃ¢mica
A lista dinÃ¢mica Ã© uma estrutura que tambÃ©m armazena elementos em sequÃªncia,
mas pode crescer ou diminuir durante a execuÃ§Ã£o do programa conforme necessÃ¡rio.

Usa ponteiros e funÃ§Ãµes de alocaÃ§Ã£o dinÃ¢mica de memÃ³ria:

malloc â†’ aloca espaÃ§o inicial.

realloc â†’ redimensiona mantendo os dados antigos.

free â†’ libera a memÃ³ria quando nÃ£o for mais usada.

ğŸ“¦ Exemplo prÃ¡tico:
Imagine uma caixa dobrÃ¡vel que pode expandir ou diminuir o tamanho conforme vocÃª adiciona ou remove itens.

ğŸ§  Exemplo em C
c
Copiar cÃ³digo
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 1. Criar a lista com 3 posiÃ§Ãµes
    int* numeros = (int*) malloc(3 * sizeof(int));

    // 2. Atribuir os valores iniciais
    numeros[0] = 10;
    numeros[1] = 20;
    numeros[2] = 30;

    // 3. Expandir a lista para 5 posiÃ§Ãµes
    numeros = (int*) realloc(numeros, 5 * sizeof(int));

    // 4. Atribuir novos valores
    numeros[3] = 40;
    numeros[4] = 50;

    // Exibir os valores da lista
    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }

    // Liberar memÃ³ria
    free(numeros);
    return 0;
}
ğŸ“ Resumo:

Pode crescer e diminuir conforme a necessidade.

A alocaÃ§Ã£o de memÃ³ria Ã© feita em tempo de execuÃ§Ã£o.

Exige o uso de ponteiros e funÃ§Ãµes especÃ­ficas de gerenciamento de memÃ³ria.

âš™ï¸ FunÃ§Ãµes Importantes
FunÃ§Ã£o	DescriÃ§Ã£o
malloc()	Aloca dinamicamente um bloco de memÃ³ria.
realloc()	Redimensiona um bloco jÃ¡ alocado.
free()	Libera a memÃ³ria previamente alocada.

ğŸ“˜ ConclusÃ£o
Tipo	CaracterÃ­sticas	Vantagens	LimitaÃ§Ãµes
EstÃ¡tica	Tamanho fixo e posiÃ§Ãµes contÃ­guas	Acesso rÃ¡pido por Ã­ndice	NÃ£o redimensionÃ¡vel
DinÃ¢mica	Usa ponteiros e cresce conforme necessÃ¡rio	FlexÃ­vel e eficiente no uso de memÃ³ria	Mais complexa de implementar

ğŸ“š Listas Encadeadas em C

As listas encadeadas sÃ£o estruturas de dados dinÃ¢micas compostas por nÃ³s (structs), onde cada nÃ³ armazena um valor (dado) e um ponteiro que indica o prÃ³ximo elemento da lista.
Elas permitem inserir e remover elementos de forma flexÃ­vel, diferente dos vetores, que tÃªm tamanho fixo.

ğŸ¥š Analogia simples

Pense em uma caÃ§a aos ovos de PÃ¡scoa ğŸ£:
Cada ovo estÃ¡ em um lugar diferente (cozinha, quarto, sala...), mas vocÃª precisa de uma pista (ponteiro) que te leve de um ovo ao prÃ³ximo.
Assim funciona uma lista encadeada â€” cada elemento sabe onde estÃ¡ o prÃ³ximo.

ğŸ§© Estrutura bÃ¡sica de um nÃ³
struct No {
    int dado;              // Onde guardamos a informaÃ§Ã£o
    struct No* proximo;    // A seta que aponta para o prÃ³ximo nÃ³
};

â• Inserindo em uma posiÃ§Ã£o especÃ­fica

Para inserir um novo elemento em uma posiÃ§Ã£o especÃ­fica da lista, vocÃª precisa:

Criar um novo nÃ³.

Percorrer a lista atÃ© a posiÃ§Ã£o desejada.

Ajustar os ponteiros para â€œencaixarâ€ o novo nÃ³ na posiÃ§Ã£o certa.

ğŸ”— Tipos de listas encadeadas
1. Lista Encadeada Simples

Cada nÃ³ aponta apenas para o prÃ³ximo elemento da lista.

struct No {
    int dado;
    struct No* proximo;
};

2. Lista Duplamente Encadeada

Cada nÃ³ aponta tanto para o prÃ³ximo quanto para o anterior, permitindo percorrer a lista nos dois sentidos.

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

3. Lista Circular Simples

O Ãºltimo nÃ³ aponta de volta para o primeiro, formando um ciclo.

struct No {
    int dado;
    struct No* proximo; // o Ãºltimo aponta para o primeiro
};

4. Lista Circular Duplamente Encadeada

Cada nÃ³ aponta para o prÃ³ximo e o anterior, e o Ãºltimo nÃ³ aponta para o primeiro (e vice-versa).

struct No {
    int dado;
    struct No* proximo;
    struct No* anterior;
};

ğŸ’¡ ObservaÃ§Ãµes

As listas encadeadas sÃ£o Ãºteis quando hÃ¡ muitas inserÃ§Ãµes e remoÃ§Ãµes dinÃ¢micas.

Elas consomem mais memÃ³ria que um vetor, pois armazenam ponteiros.

SÃ£o amplamente usadas em pilhas, filas e implementaÃ§Ãµes de Ã¡rvores.

# ğŸ§  OperaÃ§Ãµes em Listas Encadeadas (C)

Este material apresenta as principais operaÃ§Ãµes realizadas em uma **lista encadeada simples** em linguagem C: **inserÃ§Ã£o**, **remoÃ§Ã£o** e **percorrimento**.

---

## ğŸ“¦ Estrutura do NÃ³

Cada nÃ³ da lista contÃ©m um valor (`dado`) e um ponteiro (`proximo`) que aponta para o prÃ³ximo elemento.

```c
struct No {
    int dado;
    struct No* proximo;
};
```

---

## â• InserÃ§Ã£o no InÃ­cio da Lista

A funÃ§Ã£o abaixo insere um novo elemento **no inÃ­cio** da lista encadeada.

```c
void inserirNoInicio(struct No** inicio, int valor) {
    struct No* novo = (struct No*) malloc(sizeof(struct No));
    novo->dado = valor;
    novo->proximo = *inicio;
    *inicio = novo;
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
1. Aloca memÃ³ria para o novo nÃ³.  
2. Define o valor (`dado`) e faz o novo nÃ³ apontar para o antigo inÃ­cio.  
3. Atualiza o ponteiro de inÃ­cio para o novo nÃ³.  

---

## âŒ RemoÃ§Ã£o do InÃ­cio da Lista

A funÃ§Ã£o remove o **primeiro elemento** da lista, liberando a memÃ³ria alocada.

```c
void removerDoInicio(struct No** inicio) {
    if (*inicio != NULL) {
        struct No* temp = *inicio;
        *inicio = (*inicio)->proximo;
        free(temp);
    }
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
1. Verifica se a lista nÃ£o estÃ¡ vazia.  
2. Armazena o ponteiro do primeiro nÃ³ em `temp`.  
3. Move o ponteiro `inicio` para o prÃ³ximo nÃ³.  
4. Libera a memÃ³ria do nÃ³ removido.  

---

## ğŸ” Percorrer e Listar os Elementos

A funÃ§Ã£o percorre toda a lista, exibindo os valores armazenados em cada nÃ³.

```c
void listar(struct No* inicio) {
    struct No* atual = inicio;
    while (atual != NULL) {
        printf("%d\n", atual->dado);
        atual = atual->proximo;
    }
}
```

ğŸ§© **ExplicaÃ§Ã£o resumida:**  
Percorre a lista do inÃ­cio atÃ© o final, imprimindo cada elemento atÃ© encontrar `NULL`.

---

## ğŸ§© Exemplo de Uso

```c
#include <stdio.h>
#include <stdlib.h>

struct No {
    int dado;
    struct No* proximo;
};

void inserirNoInicio(struct No** inicio, int valor);
void removerDoInicio(struct No** inicio);
void listar(struct No* inicio);

int main() {
    struct No* inicio = NULL;

    inserirNoInicio(&inicio, 10);
    inserirNoInicio(&inicio, 20);
    inserirNoInicio(&inicio, 30);

    printf("Lista atual:\n");
    listar(inicio);

    removerDoInicio(&inicio);
    printf("\nApÃ³s remover o primeiro elemento:\n");
    listar(inicio);

    return 0;
}
```

---

## ğŸ§¾ Resultado Esperado

```
Lista atual:
30
20
10

ApÃ³s remover o primeiro elemento:
20
10
```

---

## ğŸ§° Conceitos Envolvidos

- Ponteiros e alocaÃ§Ã£o dinÃ¢mica (`malloc` e `free`)  
- Estruturas (`struct`)  
- Passagem por referÃªncia (`**inicio`)  
- ManipulaÃ§Ã£o de listas encadeadas  

---

ğŸ“˜ **Autor:** Matheus Leite  
ğŸ’¡ **Tema:** Estruturas de Dados â€“ Listas Encadeadas  

