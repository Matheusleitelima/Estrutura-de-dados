# Introdu√ß√£o a Filas

## Conceito
A **fila** √© uma estrutura de dados do tipo **FIFO (First In, First Out)** ‚Äî ou seja, **o primeiro a entrar √© o primeiro a sair**.

## Caracter√≠sticas
- O **primeiro elemento** da fila inicia na **posi√ß√£o 0**.  
- A fila √© percorrida do **in√≠cio (0)** at√© o **fim (√∫ltima posi√ß√£o ocupada)**.  
- Exemplo de fila com tamanho 6 (√≠ndices de 0 a 5):
- **0** ‚Üí In√≠cio da fila  
- **4** ‚Üí Fim da fila  
- **5** ‚Üí Final do vetor (limite m√°ximo da estrutura)

# L√≥gica Circular

## Conceito
A **fila circular** √© uma varia√ß√£o da fila tradicional, usada quando o **array tem tamanho fixo** e n√£o pode receber mais elementos al√©m do seu limite.

## Funcionamento
- A fila ocupa posi√ß√µes de **0 a 5** (por exemplo).  
- Quando o **√∫ltimo elemento** √© preenchido, o **pr√≥ximo elemento** deve ser inserido **no in√≠cio do vetor**, aproveitando o espa√ßo liberado por remo√ß√µes anteriores.  
- Essa abordagem evita o desperd√≠cio de espa√ßo em mem√≥ria.

## L√≥gica de Implementa√ß√£o

A ideia principal √© **fazer o √≠ndice ‚Äúvoltar‚Äù ao in√≠cio** quando ultrapassar o limite m√°ximo do vetor.  
Isso √© feito usando o **operador m√≥dulo (%)**:

```c
f->fim = (f->fim + 1) % MAX;
# Opera√ß√µes Essenciais em Filas

As principais opera√ß√µes realizadas em uma fila s√£o:  
- **Inserir (enqueue)**  
- **Retirar (dequeue)**  
- **Verificar (peek ou espiar)**  

Todas as fun√ß√µes precisam trabalhar de forma **integrada**, realizando verifica√ß√µes de estado ‚Äî como identificar se a fila est√° **cheia** ou **vazia** ‚Äî para garantir que o c√≥digo funcione corretamente.  
Uma fila bem manipulada evita falhas e torna os processos mais **previs√≠veis, organizados e eficientes**.

---

## Inserir (Enqueue)

```c
void inserir(Fila *f, Elemento e) {
    if (filaCheia(f)) // Impede inser√ß√£o se estiver cheia
        return;

    f->itens[f->fim] = e;            // Insere no final
    f->fim = (f->fim + 1) % MAX;     // Atualiza circularmente o √≠ndice
    f->total++;                      // Incrementa a contagem de elementos
}
Retirar (Dequeue)
Elemento retirar(Fila *f) {
    Elemento vazio = {-1};               // Valor padr√£o caso a fila esteja vazia
    if (filaVazia(f)) 
        return vazio;                    // Evita remo√ß√£o se estiver vazia

    Elemento e = f->itens[f->inicio];    // Armazena o item a ser removido
    f->inicio = (f->inicio + 1) % MAX;   // Atualiza o √≠ndice de in√≠cio
    f->total--;                          // Diminui o total
    return e;                            // Retorna o item removido
}
Verificar (Peek / Espiar)
Elemento espiar(Fila *f) {
    Elemento vazio = {-1};              // Valor padr√£o se a fila estiver vazia
    if (filaVazia(f))
        return vazio;                   // Impede acesso indevido

    return f->itens[f->inicio];         // Retorna o elemento da frente
}

# Declara√ß√£o, Implementa√ß√£o e Uso da Fila

## Criando uma Fila

### Estrutura de Dados do Elemento

```c
typedef struct {
    char nome[30];
    int idade;
} Pessoa;
Estrutura da Fila
c
Copiar c√≥digo
#define MAX 5

typedef struct {
    Pessoa itens[MAX];
    int inicio;
    int fim;
    int total;
} Fila;
A estrutura da fila cont√©m:

itens ‚Üí array fixo que armazena os elementos.

inicio ‚Üí posi√ß√£o do primeiro elemento da fila.

fim ‚Üí posi√ß√£o onde o pr√≥ximo elemento ser√° inserido.

total ‚Üí quantidade de elementos atualmente na fila.

Inicializar a Fila
c
Copiar c√≥digo
void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->fim = 0;
    f->total = 0;
}
Inicializa a fila definindo todos os √≠ndices e o total de elementos como zero.

Verificar Fila Cheia e/ou Vazia
c
Copiar c√≥digo
int filaCheia(Fila *f) {
    return f->total == MAX;
}

int filaVazia(Fila *f) {
    return f->total == 0;
}
Essas fun√ß√µes ajudam a controlar o estado da fila, evitando erros durante inser√ß√µes e remo√ß√µes.

Inserir (Enqueue) e Remover (Dequeue)
Inserir
c
Copiar c√≥digo
void inserir(Fila *f, Pessoa p) {
    if (f->total == MAX) {
        printf("Fila cheia. N√£o √© poss√≠vel inserir.\n");
        return;
    }
 
    f->itens[f->fim] = p;
    f->fim = (f->fim + 1) % MAX;
    f->total++;
}
Adiciona um novo elemento ao final da fila, respeitando a l√≥gica circular.

Remover
c
Copiar c√≥digo
void remover(Fila *f, Pessoa *p) {
    if (filaVazia(f)) {
        printf("Fila vazia. N√£o √© poss√≠vel remover.\n");
        return;
    }

    *p = f->itens[f->inicio];             
    f->inicio = (f->inicio + 1) % MAX;     
    f->total--;                        
}
Remove o primeiro elemento da fila, atualizando o in√≠cio de forma circular.

Mostrar Fila
c
Copiar c√≥digo
void mostrarFila(Fila *f) {
    printf("Fila: ");
    for (int i = 0, idx = f->inicio; i < f->total; i++, idx = (idx + 1) % MAX) {
        printf("[%s, %d] ", f->itens[idx].nome, f->itens[idx].idade);
    }
    printf("\n");
}
Exibe todos os elementos da fila na ordem atual, facilitando a visualiza√ß√£o e a depura√ß√£o de erros.

Conclus√£o
Compreender como declarar, inicializar e manipular filas √© essencial para manter a organiza√ß√£o sequencial dos dados.
Os conceitos de fila cheia, vazia, inser√ß√£o e remo√ß√£o formam a base do seu funcionamento.

Mostrar a fila no console ajuda a entender visualmente o comportamento da estrutura e identificar poss√≠veis erros.
Al√©m disso, o uso de estruturas bem definidas e fun√ß√µes organizadas favorece o reuso e a escalabilidade em projetos, sejam eles simples ou complexos.


# Introdu√ß√£o a Pilhas

## Conceito
Uma **pilha** √© uma estrutura de dados que segue o princ√≠pio **LIFO (Last In, First Out)** ‚Äî ou seja, o **√∫ltimo a entrar √© o primeiro a sair**.  
Ela √© amplamente utilizada em manipula√ß√£o de dados, execu√ß√£o reversa e controle de chamadas.

## Caracter√≠sticas
- Acesso restrito: apenas o elemento do topo pode ser acessado, inserido ou removido.  
- Organiza√ß√£o linear: os elementos s√£o empilhados um sobre o outro.  
- Opera√ß√µes principais:
  - **push** ‚Üí insere um elemento no topo da pilha.  
  - **pop** ‚Üí remove o elemento do topo.  
  - **peek/top** ‚Üí visualiza o elemento do topo sem remov√™-lo.

## Aplica√ß√µes Comuns

### 1. P√°ginas Web
Em navegadores, as pilhas s√£o usadas para controlar o hist√≥rico de navega√ß√£o ‚Äî a p√°gina mais recente √© a primeira a ser removida ao pressionar "voltar".

### 2. Parsing
Os **algoritmos de parsing** analisam e estruturam dados de entrada, verificando sua sintaxe e convertendo-os para um formato compreens√≠vel.  
O **parsing** usa uma **pilha** para organizar *tokens* em ordem hier√°rquica, auxiliando na an√°lise sint√°tica de **express√µes** e **linguagens de programa√ß√£o**.

### 3. Backtracking
A pilha √© utilizada para **armazenar estados anteriores**, permitindo **retornar e tentar alternativas** em problemas recursivos.  
O **backtracking** √© muito usado em softwares que permitem **desfazer a√ß√µes** em sequ√™ncia (como editores de texto e sistemas de controle de vers√£o).

---

üìò **Resumo:**  
As pilhas s√£o fundamentais na computa√ß√£o por sua simplicidade e efici√™ncia em problemas que exigem controle reverso, como an√°lise de express√µes, hist√≥rico de a√ß√µes e chamadas de fun√ß√£o.

# Opera√ß√µes Essenciais em Pilhas

As **pilhas** s√£o estruturas de dados lineares que seguem a l√≥gica **LIFO (Last In, First Out)** ‚Äî o **√∫ltimo elemento a entrar √© o primeiro a sair**.  
Elas s√£o amplamente utilizadas para controle de chamadas, desfazer a√ß√µes, parsing de express√µes e muitas outras aplica√ß√µes.

---

## üß© Opera√ß√µes Fundamentais

### 1. Inserir (`push`)

A opera√ß√£o **push** insere um novo elemento no topo da pilha.  
Antes de inserir, √© importante verificar se a pilha **n√£o est√° cheia**.

```c
void push(Pilha *p, Elemento e) {
    if (pilhaCheia(p)) {
        printf("Erro: pilha cheia. N√£o √© poss√≠vel inserir.\n");
        return;
    }

    p->topo++;              // Avan√ßa o topo
    p->itens[p->topo] = e;  // Insere o novo elemento
}
üìò Resumo:
O topo da pilha √© incrementado e o novo elemento √© colocado nessa posi√ß√£o.

2. Remover (pop)
A opera√ß√£o pop remove o elemento do topo da pilha.
Antes de remover, √© necess√°rio verificar se a pilha n√£o est√° vazia.

c
Copiar c√≥digo
void pop(Pilha *p, Elemento *e) {
    if (pilhaVazia(p)) {
        printf("Erro: pilha vazia. N√£o h√° elementos para remover.\n");
        e->valor = -1;  // Valor padr√£o para indicar falha
        return;
    }

    *e = p->itens[p->topo];  // Copia o valor do topo
    p->topo--;               // Decrementa o topo
}
üìò Resumo:
O elemento do topo √© removido e o √≠ndice do topo √© decrementado.

3. Consultar (peek)
A opera√ß√£o peek permite visualizar o elemento que est√° no topo da pilha sem remov√™-lo.

c
Copiar c√≥digo
void peek(Pilha *p, Elemento *e) {
    if (pilhaVazia(p)) {
        printf("Erro: pilha vazia. N√£o h√° elementos no topo.\n");
        e->valor = -1;  // Valor padr√£o para indicar erro
        return;
    }

    *e = p->itens[p->topo];  // Copia o elemento do topo sem alterar a pilha
}
üìò Resumo:
Usada para consultar o topo sem alterar a estrutura.

4. Liberar (free)
A opera√ß√£o free √© respons√°vel por esvaziar ou liberar a mem√≥ria da pilha.
Existem duas abordagens: array fixo e array din√¢mico.

üß± Pilha com Array Fixo
Reinicia o topo, tornando a pilha vazia novamente.

c
Copiar c√≥digo
void liberarPilha(Pilha *p) {
    p->topo = -1;  // Define a pilha como vazia novamente
}
‚öôÔ∏è Pilha com Aloca√ß√£o Din√¢mica
Libera todos os n√≥s alocados na mem√≥ria dinamicamente.

c
Copiar c√≥digo
void liberarPilha(Pilha *p) {
    while (p->topo != NULL) {
        No *remover = p->topo;
        p->topo = p->topo->prox;
        free(remover);  // Libera a mem√≥ria alocada
    }
}
üìò Resumo:

No array fixo, apenas o √≠ndice √© resetado.

Na pilha din√¢mica, cada n√≥ √© removido e a mem√≥ria liberada com free().

üí° Conclus√£o
Essas quatro opera√ß√µes ‚Äî push, pop, peek e free ‚Äî formam a base do funcionamento de qualquer pilha.
Com elas, √© poss√≠vel armazenar, acessar, remover e limpar elementos de forma organizada e eficiente.


# Comunica√ß√£o e Integra√ß√£o entre Fila e Pilha em C

Este projeto demonstra o uso conjunto das estruturas de dados **Fila (FIFO)** e **Pilha (LIFO)** em linguagem C, aplicando conceitos pr√°ticos de manipula√ß√£o e integra√ß√£o entre elas.

---

## üìò Conceitos Envolvidos

- **Fila (FIFO ‚Äì First In, First Out):**  
  Os primeiros elementos inseridos s√£o os primeiros a serem removidos.

- **Pilha (LIFO ‚Äì Last In, First Out):**  
  Os √∫ltimos elementos inseridos s√£o os primeiros a serem removidos.

Essas duas estruturas podem ser combinadas para realizar tarefas como filtragem de dados ou invers√£o de ordem, aproveitando as propriedades de cada uma.

---

## üß© Exemplo 1 ‚Äî Filtragem com Fila e Pilha

No primeiro exemplo, a fila armazena uma lista de pessoas, e a pilha √© utilizada para **separar apenas aquelas com idade superior a 60 anos**.

### üîπ L√≥gica:
1. Inserir todas as pessoas na fila.  
2. Remover cada pessoa da fila e verificar a idade.  
3. Se a idade for maior que 60, inserir na pilha de prioridade.  
4. Exibir os elementos da pilha (pessoas priorit√°rias).

### üß† Resultado:
A pilha conter√° apenas as pessoas com prioridade, preservando a l√≥gica **LIFO**, ou seja, o √∫ltimo idoso identificado ser√° exibido primeiro.

---

## üîÑ Exemplo 2 ‚Äî Revers√£o de Ordem de uma Fila

No segundo exemplo, √© realizada uma **invers√£o total da ordem dos elementos de uma fila**, utilizando uma pilha auxiliar.

### üîπ L√≥gica:
1. Inserir todas as pessoas na fila original.  
2. Remover cada pessoa da fila e empilhar (PUSH) na pilha auxiliar.  
3. Desempilhar (POP) cada pessoa da pilha e inserir em uma nova fila.  

Dessa forma, a **fila invertida** apresenta os elementos em ordem contr√°ria √† original.

### üß† Resultado:
A primeira pessoa da fila original se torna a √∫ltima na fila invertida.

---

## üßæ Estruturas Utilizadas

```c
typedef struct {
    char nome[30];
    int idade;
} Pessoa;

typedef struct {
    Pessoa dados[MAX];
    int inicio, fim;
} Fila;

typedef struct {
    Pessoa dados[MAX];
    int topo;
} Pilha;

| Fun√ß√£o                           | Descri√ß√£o                           |
| -------------------------------- | ----------------------------------- |
| `inicializarFila()`              | Define os √≠ndices iniciais da fila  |
| `inicializarPilha()`             | Define o topo da pilha como vazio   |
| `inserir()`                      | Insere um elemento na fila          |
| `remover()`                      | Remove o primeiro elemento da fila  |
| `push()`                         | Insere um elemento no topo da pilha |
| `pop()`                          | Remove o elemento do topo da pilha  |
| `exibirFila()` / `exibirPilha()` | Mostra o conte√∫do das estruturas    |

üß† Conclus√£o

Este projeto ilustra de forma pr√°tica como estruturas de dados podem trabalhar juntas para resolver problemas espec√≠ficos:

A fila organiza os elementos de forma sequencial.

A pilha permite opera√ß√µes de revers√£o e sele√ß√£o.

A integra√ß√£o entre ambas √© √∫til em diversos contextos, como:

Filtragem de dados;

Processamento de prioridades;

Invers√£o de ordem de execu√ß√£o.
