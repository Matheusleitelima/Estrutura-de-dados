# IntroduÃ§Ã£o a Filas

## Conceito
A **fila** Ã© uma estrutura de dados do tipo **FIFO (First In, First Out)** â€” ou seja, **o primeiro a entrar Ã© o primeiro a sair**.

## CaracterÃ­sticas
- O **primeiro elemento** da fila inicia na **posiÃ§Ã£o 0**.  
- A fila Ã© percorrida do **inÃ­cio (0)** atÃ© o **fim (Ãºltima posiÃ§Ã£o ocupada)**.  
- Exemplo de fila com tamanho 6 (Ã­ndices de 0 a 5):
- **0** â†’ InÃ­cio da fila  
- **4** â†’ Fim da fila  
- **5** â†’ Final do vetor (limite mÃ¡ximo da estrutura)

# LÃ³gica Circular

## Conceito
A **fila circular** Ã© uma variaÃ§Ã£o da fila tradicional, usada quando o **array tem tamanho fixo** e nÃ£o pode receber mais elementos alÃ©m do seu limite.

## Funcionamento
- A fila ocupa posiÃ§Ãµes de **0 a 5** (por exemplo).  
- Quando o **Ãºltimo elemento** Ã© preenchido, o **prÃ³ximo elemento** deve ser inserido **no inÃ­cio do vetor**, aproveitando o espaÃ§o liberado por remoÃ§Ãµes anteriores.  
- Essa abordagem evita o desperdÃ­cio de espaÃ§o em memÃ³ria.

## LÃ³gica de ImplementaÃ§Ã£o

A ideia principal Ã© **fazer o Ã­ndice â€œvoltarâ€ ao inÃ­cio** quando ultrapassar o limite mÃ¡ximo do vetor.  
Isso Ã© feito usando o **operador mÃ³dulo (%)**:

```c
f->fim = (f->fim + 1) % MAX;
# OperaÃ§Ãµes Essenciais em Filas

As principais operaÃ§Ãµes realizadas em uma fila sÃ£o:  
- **Inserir (enqueue)**  
- **Retirar (dequeue)**  
- **Verificar (peek ou espiar)**  

Todas as funÃ§Ãµes precisam trabalhar de forma **integrada**, realizando verificaÃ§Ãµes de estado â€” como identificar se a fila estÃ¡ **cheia** ou **vazia** â€” para garantir que o cÃ³digo funcione corretamente.  
Uma fila bem manipulada evita falhas e torna os processos mais **previsÃ­veis, organizados e eficientes**.

---

## Inserir (Enqueue)

```c
void inserir(Fila *f, Elemento e) {
    if (filaCheia(f)) // Impede inserÃ§Ã£o se estiver cheia
        return;

    f->itens[f->fim] = e;            // Insere no final
    f->fim = (f->fim + 1) % MAX;     // Atualiza circularmente o Ã­ndice
    f->total++;                      // Incrementa a contagem de elementos
}
Retirar (Dequeue)
Elemento retirar(Fila *f) {
    Elemento vazio = {-1};               // Valor padrÃ£o caso a fila esteja vazia
    if (filaVazia(f)) 
        return vazio;                    // Evita remoÃ§Ã£o se estiver vazia

    Elemento e = f->itens[f->inicio];    // Armazena o item a ser removido
    f->inicio = (f->inicio + 1) % MAX;   // Atualiza o Ã­ndice de inÃ­cio
    f->total--;                          // Diminui o total
    return e;                            // Retorna o item removido
}
Verificar (Peek / Espiar)
Elemento espiar(Fila *f) {
    Elemento vazio = {-1};              // Valor padrÃ£o se a fila estiver vazia
    if (filaVazia(f))
        return vazio;                   // Impede acesso indevido

    return f->itens[f->inicio];         // Retorna o elemento da frente
}

# DeclaraÃ§Ã£o, ImplementaÃ§Ã£o e Uso da Fila

## Criando uma Fila

### Estrutura de Dados do Elemento

```c
typedef struct {
    char nome[30];
    int idade;
} Pessoa;
Estrutura da Fila
c
Copiar cÃ³digo
#define MAX 5

typedef struct {
    Pessoa itens[MAX];
    int inicio;
    int fim;
    int total;
} Fila;
A estrutura da fila contÃ©m:

itens â†’ array fixo que armazena os elementos.

inicio â†’ posiÃ§Ã£o do primeiro elemento da fila.

fim â†’ posiÃ§Ã£o onde o prÃ³ximo elemento serÃ¡ inserido.

total â†’ quantidade de elementos atualmente na fila.

Inicializar a Fila
c
Copiar cÃ³digo
void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->fim = 0;
    f->total = 0;
}
Inicializa a fila definindo todos os Ã­ndices e o total de elementos como zero.

Verificar Fila Cheia e/ou Vazia
c
Copiar cÃ³digo
int filaCheia(Fila *f) {
    return f->total == MAX;
}

int filaVazia(Fila *f) {
    return f->total == 0;
}
Essas funÃ§Ãµes ajudam a controlar o estado da fila, evitando erros durante inserÃ§Ãµes e remoÃ§Ãµes.

Inserir (Enqueue) e Remover (Dequeue)
Inserir
c
Copiar cÃ³digo
void inserir(Fila *f, Pessoa p) {
    if (f->total == MAX) {
        printf("Fila cheia. NÃ£o Ã© possÃ­vel inserir.\n");
        return;
    }
 
    f->itens[f->fim] = p;
    f->fim = (f->fim + 1) % MAX;
    f->total++;
}
Adiciona um novo elemento ao final da fila, respeitando a lÃ³gica circular.

Remover
c
Copiar cÃ³digo
void remover(Fila *f, Pessoa *p) {
    if (filaVazia(f)) {
        printf("Fila vazia. NÃ£o Ã© possÃ­vel remover.\n");
        return;
    }

    *p = f->itens[f->inicio];             
    f->inicio = (f->inicio + 1) % MAX;     
    f->total--;                        
}
Remove o primeiro elemento da fila, atualizando o inÃ­cio de forma circular.

Mostrar Fila
c
Copiar cÃ³digo
void mostrarFila(Fila *f) {
    printf("Fila: ");
    for (int i = 0, idx = f->inicio; i < f->total; i++, idx = (idx + 1) % MAX) {
        printf("[%s, %d] ", f->itens[idx].nome, f->itens[idx].idade);
    }
    printf("\n");
}
Exibe todos os elementos da fila na ordem atual, facilitando a visualizaÃ§Ã£o e a depuraÃ§Ã£o de erros.

ConclusÃ£o
Compreender como declarar, inicializar e manipular filas Ã© essencial para manter a organizaÃ§Ã£o sequencial dos dados.
Os conceitos de fila cheia, vazia, inserÃ§Ã£o e remoÃ§Ã£o formam a base do seu funcionamento.

Mostrar a fila no console ajuda a entender visualmente o comportamento da estrutura e identificar possÃ­veis erros.
AlÃ©m disso, o uso de estruturas bem definidas e funÃ§Ãµes organizadas favorece o reuso e a escalabilidade em projetos, sejam eles simples ou complexos.


# IntroduÃ§Ã£o a Pilhas

## Conceito
Uma **pilha** Ã© uma estrutura de dados que segue o princÃ­pio **LIFO (Last In, First Out)** â€” ou seja, o **Ãºltimo a entrar Ã© o primeiro a sair**.  
Ela Ã© amplamente utilizada em manipulaÃ§Ã£o de dados, execuÃ§Ã£o reversa e controle de chamadas.

## CaracterÃ­sticas
- Acesso restrito: apenas o elemento do topo pode ser acessado, inserido ou removido.  
- OrganizaÃ§Ã£o linear: os elementos sÃ£o empilhados um sobre o outro.  
- OperaÃ§Ãµes principais:
  - **push** â†’ insere um elemento no topo da pilha.  
  - **pop** â†’ remove o elemento do topo.  
  - **peek/top** â†’ visualiza o elemento do topo sem removÃª-lo.

## AplicaÃ§Ãµes Comuns

### 1. PÃ¡ginas Web
Em navegadores, as pilhas sÃ£o usadas para controlar o histÃ³rico de navegaÃ§Ã£o â€” a pÃ¡gina mais recente Ã© a primeira a ser removida ao pressionar "voltar".

### 2. Parsing
Os **algoritmos de parsing** analisam e estruturam dados de entrada, verificando sua sintaxe e convertendo-os para um formato compreensÃ­vel.  
O **parsing** usa uma **pilha** para organizar *tokens* em ordem hierÃ¡rquica, auxiliando na anÃ¡lise sintÃ¡tica de **expressÃµes** e **linguagens de programaÃ§Ã£o**.

### 3. Backtracking
A pilha Ã© utilizada para **armazenar estados anteriores**, permitindo **retornar e tentar alternativas** em problemas recursivos.  
O **backtracking** Ã© muito usado em softwares que permitem **desfazer aÃ§Ãµes** em sequÃªncia (como editores de texto e sistemas de controle de versÃ£o).

---

ğŸ“˜ **Resumo:**  
As pilhas sÃ£o fundamentais na computaÃ§Ã£o por sua simplicidade e eficiÃªncia em problemas que exigem controle reverso, como anÃ¡lise de expressÃµes, histÃ³rico de aÃ§Ãµes e chamadas de funÃ§Ã£o.

# OperaÃ§Ãµes Essenciais em Pilhas

As **pilhas** sÃ£o estruturas de dados lineares que seguem a lÃ³gica **LIFO (Last In, First Out)** â€” o **Ãºltimo elemento a entrar Ã© o primeiro a sair**.  
Elas sÃ£o amplamente utilizadas para controle de chamadas, desfazer aÃ§Ãµes, parsing de expressÃµes e muitas outras aplicaÃ§Ãµes.

---

## ğŸ§© OperaÃ§Ãµes Fundamentais

### 1. Inserir (`push`)

A operaÃ§Ã£o **push** insere um novo elemento no topo da pilha.  
Antes de inserir, Ã© importante verificar se a pilha **nÃ£o estÃ¡ cheia**.

```c
void push(Pilha *p, Elemento e) {
    if (pilhaCheia(p)) {
        printf("Erro: pilha cheia. NÃ£o Ã© possÃ­vel inserir.\n");
        return;
    }

    p->topo++;              // AvanÃ§a o topo
    p->itens[p->topo] = e;  // Insere o novo elemento
}
ğŸ“˜ Resumo:
O topo da pilha Ã© incrementado e o novo elemento Ã© colocado nessa posiÃ§Ã£o.

2. Remover (pop)
A operaÃ§Ã£o pop remove o elemento do topo da pilha.
Antes de remover, Ã© necessÃ¡rio verificar se a pilha nÃ£o estÃ¡ vazia.

c
Copiar cÃ³digo
void pop(Pilha *p, Elemento *e) {
    if (pilhaVazia(p)) {
        printf("Erro: pilha vazia. NÃ£o hÃ¡ elementos para remover.\n");
        e->valor = -1;  // Valor padrÃ£o para indicar falha
        return;
    }

    *e = p->itens[p->topo];  // Copia o valor do topo
    p->topo--;               // Decrementa o topo
}
ğŸ“˜ Resumo:
O elemento do topo Ã© removido e o Ã­ndice do topo Ã© decrementado.

3. Consultar (peek)
A operaÃ§Ã£o peek permite visualizar o elemento que estÃ¡ no topo da pilha sem removÃª-lo.

c
Copiar cÃ³digo
void peek(Pilha *p, Elemento *e) {
    if (pilhaVazia(p)) {
        printf("Erro: pilha vazia. NÃ£o hÃ¡ elementos no topo.\n");
        e->valor = -1;  // Valor padrÃ£o para indicar erro
        return;
    }

    *e = p->itens[p->topo];  // Copia o elemento do topo sem alterar a pilha
}
ğŸ“˜ Resumo:
Usada para consultar o topo sem alterar a estrutura.

4. Liberar (free)
A operaÃ§Ã£o free Ã© responsÃ¡vel por esvaziar ou liberar a memÃ³ria da pilha.
Existem duas abordagens: array fixo e array dinÃ¢mico.

ğŸ§± Pilha com Array Fixo
Reinicia o topo, tornando a pilha vazia novamente.

c
Copiar cÃ³digo
void liberarPilha(Pilha *p) {
    p->topo = -1;  // Define a pilha como vazia novamente
}
âš™ï¸ Pilha com AlocaÃ§Ã£o DinÃ¢mica
Libera todos os nÃ³s alocados na memÃ³ria dinamicamente.

c
Copiar cÃ³digo
void liberarPilha(Pilha *p) {
    while (p->topo != NULL) {
        No *remover = p->topo;
        p->topo = p->topo->prox;
        free(remover);  // Libera a memÃ³ria alocada
    }
}
ğŸ“˜ Resumo:

No array fixo, apenas o Ã­ndice Ã© resetado.

Na pilha dinÃ¢mica, cada nÃ³ Ã© removido e a memÃ³ria liberada com free().

ğŸ’¡ ConclusÃ£o
Essas quatro operaÃ§Ãµes â€” push, pop, peek e free â€” formam a base do funcionamento de qualquer pilha.
Com elas, Ã© possÃ­vel armazenar, acessar, remover e limpar elementos de forma organizada e eficiente.

